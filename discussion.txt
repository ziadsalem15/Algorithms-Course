1)
2)  Linked List:
      a) Insertion - O(1)
      b) Contains (Search) - O(n)
      c) pop_min (Deletion) - O(n)
      d) Empty - O(1)
      e) tidy - O(n)

    Sorted Linked list:
      a) Insertion - O(n)
      b) Contains(search) - O(n)
      c) pop_min (Deletion) - O(1)
      d) Empty - O(1)
      e) tidy - O(n)

    AVL Tree:
      a) Insertion - O(logn)
      b) Contains (Search) - O(logn)
      c) pop_min (Deletion) - O(logn)
      d) Empty - O(1)
      e) tidy - O(logn)

    Binary Heap:
      a) Insertion - O(logn)
      b) Contains (Search) - O(n)
      c) pop_min (Deletion)- O(logn)
      d) Empty - O(1)
      e) tidy - O(n)

    Skip List:
      a) Insertion - O(n + h)
      b) Contains (Search) - O(n + h)
      c) pop_min (Deletion) - O(h)
      d) Empty - O(1)
      e) tidy - O(n)

3) AVL tree and Binary heap is the best for concat_finder.c as their complexity
is the same which is logn
AVL tree is the best for sorting.c as its complexity is the fastest which is logn 

Prediction For both of them it is going to be an AVL tree since it is objectively
the best. I assume it mostly depends on the amount of data but if we consider a
big amount of data an AVL tree is going to be the best.
