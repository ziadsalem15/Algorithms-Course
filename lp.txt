##################################### Task 3C: Linear Programming #########################################

1] Describe how we can use the Simplex algorithm to solve the Fractional Knapsack problem.
You should begin by clearly stating the fractional knapsack problem and then describe
the steps required to transform this into the input to the Simplex algorithm.
You should also comment on how the solution generated by the Simplex algorithm can be translated
into a solution the Fractional Knapsack problem.

A:: First I will start by describing the fractional knapsack problem where a knapsack
of a certain capacity is given, with some items that have weight and value. Our aim is to
to get the maximum value with weight equal to or less than the knapsack capacity.
In fractional, we can take portions of items so the profit of calculation is the sum of
portions taken from the complete solution in ratio by the partial weight considered.

The simplex algorithm is the classical method to solve the optimization problem
of linear programming.

To transform this into the input to the simplex algorithm :
  >> We first transform the knapsack problem into linear programming one.
      (y = p.T * X) where p is a profit column vector containing
      the profit for each item and X is a column vector that have the fraction of item
      we will add to the knapsack and p.T means the transpose of the vector. We need to
      take care of the constraints we have which is the capacity of the knapsack.
      (W * X <= capacityOfKnapsack) where W is a vector containing the weights and X is a column vector
      that have the fraction of item we will add to the knapsack. We need to take any time only once
      and the portion of item to be added has to be non-negative(between 0 and 1) thats for sure.
      To make sure the X is less than 1 , append an identity matrix of size = to number of elements
      to matrix W and then append to capacityOfKnapsack vector "1"s equal to number of items we have.
  >> To make sure the problem is in the standard form now we check on number of staff:
    >< all variables have non-negative constraints
    >< we only have inequalities no equalities where it is in the form a.x + b.y <= c
    >< the maximisation function is the objective one.

  >> We now need to add slack variables(which represent the difference between the left hand side and
      the right hand side of the inequality) to transform it into slack form now:
      So now : W * X + S = capacityOfKnapsack where S is a vector of slack variables.

  >> The Simplex algorithm accepts the slack form as input as we have free and basic
  variables and the objective function. What we want to achieve is setting the free
  variables to zero and solving the inequalities for the basic variables. We can use
  gaussian elimination in this. Gaussian elimination, also known as row reduction,
  is an algorithm in linear algebra for solving a system of linear equations. It is usually understood
  as a sequence of operations performed on the corresponding matrix of coefficients. So, the
  the slack variables will keep substituting until an optimal basic solution is found.

  >> The basic variables we have are the slack variables (s1, s2, ...). Setting non-basic variables to zero gives
  a basic solution which is almost the same as starting at the origin. So, the solution we have now is :
  (x1, x2, ..., xn, s1, s2, ..., s(n+1)) =  (0, 0, ..., 0, W, 1, 1, ..., 1)

  >> To make the solution we have now optimal we need to make the value of the objective function bigger
  by changing values of p[i]. We now need a pivot and swap an existing basic variable|(out) with
  a non basic variable(in). Using gaussian elimination we make the value next to the one we just entered
  ready to go out by making it 1 and the others as zeros.

  >> After that we can read the solution by associating the basic variable with the
  value of capacityOfKnapsack in the same column. We check again and if we still have negative values
  we repeat the above paragraph again.

  >> After doing this , the value for x[i] means the portion of the item to be included in
  knapsack.

  >> To find the maximum profit we multiply x[i] * p[i] and summing it for every item i we have


##############################################################################
##############################################################################

2] Will the previous approach always provide the optimal solution (explain)?
How does its complexity compare to the greedy approach for the Fractional Knapsack problem?

A:: Yes, it provides optimal solution. As long as we are sure that we are going to make the
correct simplifications where without it most probably we will have an infeasible solution.

Time Complexities:
Simplex algorithm --> O(2^n), sometimes it is polynomial as well
Greedy algorithm --> O(nlogn)
So , time complexity for the greedy algorithm is better than simplex algorithm.

##############################################################################
##############################################################################

3] What is the difference between a linear program and a mixed integer linear program?
You should comment on the comparative complexity of the two problems.

A: Linear Program provides a solution in real numbers while the mixed linear program provides
some solution as integers.
Linear program is in P, but when we consider mixed Linear program we have two cases,
Np-complete if it is a decision problem or Np-hard if it is an optimisation problem, where it depends
on how you consider the problem.

##############################################################################
##############################################################################

4] (This is a difficult question that you may wish to skip if you do not have much time left. It will require some additional reading.)
Look up the concept of a relaxation of a (mixed) integer linear program and explain how
it might let us use the Simplex algorithm to solve the 0/1 Knapsack problem.

A:: the relaxation of a (mixed) integer linear program is the problem that arises by
removing the integrality constraint of each variable. The resulting relaxation is a linear program.

>> To transform it into a linear program we drop the integrality constraint
by relaxation.

Once we have this we can use branch and bound to find a solution for 0/1 knapsack problem:
    Assume P is the knapsack problem and R is the relaxation of P:
    if (optimal for P):
      all variables = {0,1}
      done
    else:
      we let b[i] is the optimal solution for R and x[i] is an int value
      1stChildP = P & x[i] <= floor(b[i])
      2ndChildP = P & x[i] >= ceiling(b[i])

    Using b&b we get the best solution for 1stChildP and 2ndChildP

##############################################################################
##############################################################################
